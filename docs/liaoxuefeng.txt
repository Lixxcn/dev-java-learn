一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致；
使用javac可以将.java源码编译成.class字节码；
使用java可以运行一个已编译的Java程序，参数是类名。
Java提供了两种变量类型：基本类型和引用类型
基本类型包括整型，浮点型，布尔型，字符型。
变量可重新赋值，等号是赋值语句，不是数学意义的等号。
常量在初始化后不可重新赋值，使用常量便于理解程序意图。
整数运算的结果永远是精确的；
运算结果会自动提升；
可以强制转型，但超出范围的强制转型会得到错误的结果；
应该选择合适范围的整型（int或long），没有必要为了节省内存而使用byte和short进行整数运算
浮点数常常无法精确表示，并且浮点数的运算结果可能有误差；
比较两个浮点数通常比较它们的差的绝对值是否小于一个特定值；
整型和浮点型运算时，整型会自动提升为浮点型；
可以将浮点型强制转为整型，但超出范围后将始终返回整型的最大值。
与运算和或运算是短路运算；
三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。
Java的字符类型char是基本类型，字符串类型String是引用类型；
基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象；
引用类型的变量可以是空值null；
要区分空值null和空字符串""。
数组是同一数据类型的集合，数组一旦创建后，大小就不可变；
可以通过索引访问数组元素，但索引超出范围将报错；
数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；
Java提供的输出包括：System.out.println() / print() / printf()，其中printf()可以格式化输出；
Java提供Scanner对象来方便输入，读取对应的类型可以使用：scanner.nextLine() / nextInt() / nextDouble() / ...
if ... else可以做条件判断，else是可选的；
不推荐省略花括号{}；
多个if ... else串联要特别注意判断顺序；
要注意if的边界条件；
要注意浮点数判断相等不能直接用==运算符；
引用类型判断内容相等要使用equals()，注意避免NullPointerException。
switch语句可以做多重选择，然后执行匹配的case语句后续代码；
switch的计算结果必须是整型、字符串或枚举类型；
注意千万不要漏写break，建议打开fall-through警告；
总是写上default，建议打开missing default警告；
从Java 14开始，switch语句正式升级为表达式，不再需要break，并且允许使用yield返回值。
while循环先判断循环条件是否满足，再执行循环语句；
while循环可能一次都不执行；
编写循环时要注意循环条件，并避免死循环。
do while先执行循环，再判断条件；
do while循环会至少执行一次。
for循环通过计数器可以实现复杂循环；
for each循环可以直接遍历数组的每个元素；
最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器；
break语句可以跳出当前循环；
break语句通常配合if，在满足条件时提前结束整个循环；
break语句总是跳出最近的一层循环；
continue语句可以提前结束本次循环；
continue语句通常配合if，在满足条件时提前结束本次循环。
遍历数组可以使用for循环，for循环可以访问数组索引，for each循环直接迭代每个数组元素，但无法获取索引；
使用Arrays.toString()可以快速获取数组内容。
常用的排序算法有冒泡排序、插入排序和快速排序等；
冒泡排序使用两层for循环实现排序；
交换两个变量的值需要借助一个临时变量；
可以直接使用Java标准库提供的Arrays.sort()进行排序；
对数组排序会直接修改数组本身。
二维数组就是数组的数组，三维数组就是二维数组的数组；
多维数组的每个数组元素长度都不要求相同；
打印多维数组可以使用Arrays.deepToString()；
最常见的多维数组是二维数组，访问二维数组的一个元素使用array[row][col]。
命令行参数类型是String[]数组；
命令行参数由JVM接收用户输入并传给main方法；
如何解析命令行参数需要由程序自己实现。
在OOP中，class和instance是“模版”和“实例”的关系；
定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；
class定义的field，在每个instance都会拥有各自的field，且互不干扰；
通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；
访问实例字段的方法是变量名.字段名；
指向instance的变量都是引用变量。
方法可以让外部代码安全地访问实例字段；
方法是一组执行语句，并且可以执行任意逻辑；
方法内部遇到return时返回，void表示不返回任何值（注意和返回null不同）；
外部代码通过public方法操作实例，内部代码可以调用private方法；
理解方法的参数绑定。
实例在创建时通过new操作符会调用其对应的构造方法，构造方法用于初始化实例；
没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法；
可以定义多个构造方法，编译器根据参数自动判断；
可以在一个构造方法内部调用另一个构造方法，便于代码复用。
方法重载是指多个方法的方法名相同，但各自的参数不同；
重载方法应该完成类似的功能，参考String的indexOf()；
重载方法返回值类型应该相同。
继承是面向对象编程的一种强大的代码复用方式；
Java只允许单继承，所有类最终的根类是Object；
protected允许子类访问父类的字段和方法；
子类的构造方法可以通过super()调用父类的构造方法；
可以安全地向上转型为更抽象的类型；
可以强制向下转型，最好借助instanceof判断；
子类和父类的关系是is，has关系不能用继承。
子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；
Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；
final修饰符有多种作用：
final修饰的方法可以阻止被覆写；
final修饰的class可以阻止被继承；
final修饰的field必须在创建对象时初始化，随后不可修改。
通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
如果不实现抽象方法，则该子类仍是一个抽象类；
面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。
Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；
接口也是数据类型，适用于向上转型和向下转型；
接口的所有方法都是抽象方法，接口不能定义实例字段；
接口可以定义default方法（JDK>=1.8）。
静态字段属于所有实例“共享”的字段，实际上是属于class的字段；
调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法；
静态方法常用于工具类和辅助方法。
Java内建的package机制是为了避免class命名冲突；
JDK的核心类使用java.lang包，编译器会自动导入；
JDK的其它常用类定义在java.util.*，java.math.*，java.text.*，……；
包名推荐使用倒置的域名，例如org.apache。
Java内建的访问权限包括public、protected、private和package权限；
Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束；
final修饰符不是访问权限，它可以修饰class、field和method；
一个.java文件只能包含一个public类，但可以包含多个非public类。
Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种；
Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限；
Static Nested Class是独立类，但拥有Outer Class的private访问权限。
JVM通过环境变量classpath决定搜索class的路径和顺序；
强烈建议不要设置系统环境变量classpath，建议始终通过-cp命令传入；
jar包本质上是zip格式，相当于目录，可以包含很多.class文件，方便下载和使用；
MANIFEST.MF文件可以提供jar包的信息，如Main-Class，这样可以直接运行jar包。
高版本的JDK可编译输出低版本兼容的class文件，但需注意，低版本的JDK可能不存在高版本JDK添加的类和方法，导致运行时报错。
运行时使用哪个JDK版本，编译时就尽量使用同一版本的JDK编译源码。
Java 9引入的模块目的是为了管理依赖；
使用模块可以按需打包JRE；
使用模块对类的访问权限有了进一步限制。
Java字符串String是不可变对象；
字符串操作不改变原字符串内容，而是返回新字符串；
常用的字符串操作：提取子串、查找、替换、大小写转换等；
Java使用Unicode编码表示String和char；
转换编码就是将String和byte[]转换，需要指定编码；
转换为byte[]时，始终优先考虑UTF-8编码。
StringBuilder是可变对象，用来高效拼接字符串；
StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身；
StringBuffer是StringBuilder的线程安全版本，现在很少使用。
Java核心库提供的包装类型可以把基本类型包装为class；
自动装箱和自动拆箱都是在编译期完成的（JDK>=1.5）；
装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；
包装类型的比较必须使用equals()；
整数和浮点数的包装类型都继承自Number；
包装类型提供了大量实用方法。